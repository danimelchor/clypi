{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Clypi","text":"<p> <p></p> <p>Your all-in-one for beautiful, lightweight, prod-ready CLIs</p> <p>Note</p> <p>Clypi is still being maintained, but considered a finished library. If you have any issues or feature requests, please feel free to open an issue. Cheers!</p>"},{"location":"#docs","title":"\ud83d\udcd6 Docs","text":"<p>Read our docs to get started. You can also look at the API reference for examples and a full API reference. Otherwise, feel free to browse the source code in the GitHub repository.</p>"},{"location":"#what-is-clypi","title":"What is clypi?","text":"<p>I've been working with Python-based CLIs for several years with many users and strict quality requirements and always run into the sames problems with the go-to packages. Therefore, I decided to embark on a journey to build a lightweight, intuitive, pretty, and production ready framework. Here are the key features:</p> <ul> <li>Type safe: making use of dataclass-like commands, you can easily specify the types you want for each argument and clypi automatically parses and validates them.</li> <li>Asynchronous: clypi is built to run asynchronously to provide the best performance possible when re-rendering.</li> <li>Easily testable: thanks to being type checked and to using it's own parser, clypi let's you test each individual step. From from parsing command-line arguments to running your commands in tests just like a user would.</li> <li>Composable: clypi lets you easily reuse arguments across subcommands without having to specify them again.</li> <li>Configurable: clypi lets you configure almost everything you'd like to configure. You can create your own themes, help pages, error messages, and more!</li> </ul>"},{"location":"#define-arguments-with-type-annotations","title":"Define Arguments with Type Annotations","text":"<p>Just like you do with dataclasses, clypi CLI arguments can defined as class-level type annotations.</p> <pre><code>from clypi import Command\nfrom typing_extensions import override\n\nclass MyCli(Command):\n    name: str  # Automatically parsed as `--name &lt;NAME&gt;`.\n\n    @override\n    async def run(self):\n        print(f\"Hi {self.name}!\")\n\ncli = MyCli.parse()\ncli.start()\n</code></pre>"},{"location":"#need-more-control","title":"Need more control?","text":"<p>Use our <code>arg</code> helper and built-in parsers to define defaults, parsers, groups, and more!</p> <pre><code>from clypi import Command, arg\nimport clypi.parsers as cp\n\nclass MyCli(Command):\n    threads: int = arg(\n        default=4,\n        parser=cp.Int(min=1, max=10),  # Restrict to values 1-10\n    )\n\ncli = MyCli.parse()\ncli.start()\n</code></pre>"},{"location":"#easily-document-your-clis","title":"Easily document your CLIs","text":"<p>Using docstrings automatically applies them to your CLI's <code>--help</code> page</p> <pre><code>from clypi import Command, arg\n\nclass MyCli(Command):\n    \"\"\"A simple CLI\"\"\"\n    threads: int = arg(\n        default=4,\n        help=\"The number of threads to run the tool with\",\n    )\n\ncli = MyCli.parse()\ncli.start()\n</code></pre>"},{"location":"#intuitive-subcommands-groups-of-commands","title":"Intuitive subcommands (groups of commands)","text":"<p>Just create and compose more clypi commands!</p> <pre><code>from clypi import Command, arg\n\nclass Lint(Command):\n    \"\"\"Lint a set of files\"\"\"\n    verbose: bool = arg(inherited=True)  # Inherits the argument def from `MyCli`\n\nclass Run(Command):\n    \"\"\"Run a set of files\"\"\"\n\nclass MyCli(Command):\n    \"\"\"A simple CLI to lint and run files\"\"\"\n    subcommand: Lint | Run\n    verbose: bool = arg(False, help=\"Whether to show more output\")\n\ncli = MyCli.parse()\ncli.start()\n</code></pre>"},{"location":"#getting-started","title":"Getting started","text":"<pre><code>uv add clypi  # or `pip install clypi`\n</code></pre>"},{"location":"#beautiful-by-default","title":"\ud83e\ude90 Beautiful by default","text":"<p>Clypi comes with pre-defined themes and modern features like suggestions on typos:</p> <pre><code>uv run -m examples.cli run run-seria\n</code></pre> <p></p>"},{"location":"#configurable","title":"\ud83d\udee0\ufe0f Configurable","text":"<p>Clypi lets you configure the app globally. This means that all the styling will be easy, uniform across your entire app, and incredibly maintainable.</p> <p>For example, this is how you'd achieve a UI like <code>uv</code>'s CLI:</p> examples/uv/__main__.py<pre><code>from clypi import ClypiConfig, ClypiFormatter, Styler, Theme, configure\n\nconfigure(\n    ClypiConfig(\n        theme=Theme(\n            usage=Styler(fg=\"green\", bold=True),\n            usage_command=Styler(fg=\"cyan\", bold=True),\n            usage_args=Styler(fg=\"cyan\"),\n            section_title=Styler(fg=\"green\", bold=True),\n            subcommand=Styler(fg=\"cyan\", bold=True),\n            long_option=Styler(fg=\"cyan\", bold=True),\n            short_option=Styler(fg=\"cyan\", bold=True),\n            positional=Styler(fg=\"cyan\"),\n            placeholder=Styler(fg=\"cyan\"),\n            prompts=Styler(fg=\"green\", bold=True),\n        ),\n        help_formatter=ClypiFormatter(\n            boxed=False,\n            show_option_types=False,\n        ),\n    )\n)\n</code></pre> <pre><code>uv run -m examples.uv add -c\n</code></pre> <p></p> <p>Read the docs and API reference.</p>"},{"location":"#colors","title":"\ud83c\udf08 Colors","text":"<p>Clypi let's you easily print colorful formatted output full:</p> examples/colors.py<pre><code># demo.py\nimport clypi\n\n# Print with colors directly\nclypi.cprint(\"Some colorful text\", fg=\"green\", reverse=True, bold=True, italic=True)\n\n# Style text\nprint(clypi.style(\"This is blue\", fg=\"blue\"), \"and\", clypi.style(\"this is red\", fg=\"red\"))\n\n# Store a styler and reuse it\nwrong = clypi.Styler(fg=\"red\", strikethrough=True)\nprint(\"The old version said\", wrong(\"Pluto was a planet\"))\nprint(\"The old version said\", wrong(\"the Earth was flat\"))\n</code></pre> <pre><code>uv run -m examples.colors\n</code></pre> <p></p> <p>Read the docs</p>"},{"location":"#spinners","title":"\ud83c\udf00 Spinners","text":"<p>You can easily use spinners to indicate progress on long-running tasks:</p> examples/spinner.py<pre><code>import asyncio\nfrom clypi import spinner\n\n@spinner(\"Doing work\", capture=True)\nasync def do_some_work():\n    await asyncio.sleep(2)\n\nasyncio.run(do_some_work())\n</code></pre> <p><code>uv run -m examples.spinner</code></p> <p>https://github.com/user-attachments/assets/2065b3dd-c73c-4e21-b698-8bf853e8e520</p> <p>Read the docs</p>"},{"location":"#async-by-default","title":"\ud83d\udd00 Async by default","text":"<p><code>clypi</code> was built with an async-first mentality. Asynchronous code execution is incredibly valuable for applications like CLIs where we want to update the UI as we take certain actions behind the scenes. Most often, these actions can be made asynchronous since they involve things like file manipulation, network requests, subprocesses, etc.</p>"},{"location":"#type-checking","title":"\ud83d\udc0d Type-checking","text":"<p>This library is fully type-checked. This means that all types will be correctly inferred from the arguments you pass in.</p> <p>In this example your editor will correctly infer the type:</p> <pre><code>import clypi\n\nhours = clypi.prompt(\n    \"How many hours are there in a year?\",\n    parser=lambda x: float(x) if isinstance(x, str) else timedelta(days=len(x)),\n)\nreveal_type(hours)  # Type of \"res\" is \"float | timedelta\"\n</code></pre>"},{"location":"#why-should-i-care","title":"Why should I care?","text":"<p>Type checking will help you catch issues way earlier in the development cycle. It will also provide nice autocomplete features in your editor that will make you faster \udb85\udc0b.</p>"},{"location":"#comparison-to-other-packages","title":"\ud83d\udce6 Comparison to other packages","text":"<p>Note</p> <p>This section is my (danimelchor's) personal opinion I've gathered during my time working with Python CLIs. If you do not agree, please feel free to reach out and I'm open to discussing / trying out new tools.</p> <p>Argparse is the builtin solution for CLIs, but, as expected, it's functionality is very restrictive. It is not very extensible, it's UI is not pretty and very hard to change, lacks type checking and type parsers, and does not offer any modern UI components that we all love.</p> <p>Rich is too complex and threaded. The vast catalog of UI components they offer is amazing, but it is both easy to get wrong and break the UI, and too complicated/verbose to onboard coworkers to. It's prompting functionality is also quite limited and it does not offer command-line arguments parsing.</p> <p>Click is too restrictive. It enforces you to use decorators, which is great for locality of behavior but not so much if you're trying to reuse arguments across your application. It is also painful to deal with the way arguments are injected into functions and very easy to miss one, misspell, or get the wrong type. Click is also fully untyped for the core CLI functionality and hard to test.</p> <p>Typer seems great! I haven't personally tried it, but I have spent time looking through their docs and code. I think the overall experience is a step up from click's but, at the end of the day, it's built on top of it. Hence, many of the issues are the same: testing is hard, shared contexts are untyped, their built-in type parsing is quite limited, and it does not offer modern features like suggestions on typos. Using <code>Annotated</code> types is also very verbose inside function definitions.</p>"},{"location":"packaging/","title":"Building and distributing your CLIs","text":"<p>To build and distribute you own CLI I recommend you use uv..</p> <p>In this quick walkthrough we'll be creating a CLI called <code>zit</code>, a basic clone of git.</p>"},{"location":"packaging/#creating-a-new-cli","title":"Creating a new CLI","text":"<p>First, you'll want to create a project. For that, follow uv's most up to date documentation about creating a new project.</p> <p>A quick summary at the time of writing is:</p> <ol> <li> <p>Create a project directory:</p> <p>mkdir zitcd zit</p> </li> <li> <p>Initialize a project:</p> <p>uv init</p> </li> <li> <p>Install clypi:</p> <p>uv add clypi</p> </li> <li> <p>Code your CLI. <code>uv</code> created a <code>main.py</code> file but you should create your own python package inside a subdirectory called <code>zit</code>. Inside that subdirectory create an empty file called <code>__init__.py</code> and a file called <code>main.py</code> with the following content:</p> <p>tree.\u251c\u2500\u2500 README.md\u251c\u2500\u2500 pyproject.toml\u251c\u2500\u2500 uv.lock\u2514\u2500\u2500 zit    \u251c\u2500\u2500 init.py    \u2514\u2500\u2500 main.py</p> <pre><code># zit/main.py\nimport clypi\nfrom clypi import Command, arg\n\nclass Zit(Command):\n    \"\"\"\n    A git clone, but much slower ;)\n    \"\"\"\n    verbose: bool = arg(False, short=\"v\")\n\n    async def run(self):\n        clypi.cprint(\"Sorry I don't know how to use git, it's too hard!\", fg=\"yellow\")\n        if self.verbose:\n            clypi.cprint(\"asdkjnbsvaeusbvkajhfnuehfvousadhvuashfqei\" * 100)\n\ndef main():\n    \"\"\"\n    This will be the entrypoint for our CLI\n    \"\"\"\n    zit = Zit.parse()\n    zit.start()\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> </li> <li> <p>Test out your new CLI. You can run it locally with:</p> <p>uv run ./zit/main.py</p> </li> <li> <p>You'll need to add a build system so that <code>uv</code> understands this is a package you want to distribute and people to install. Add the following to your <code>pyproject.toml</code></p> <pre><code>+ [build-system]\n+ requires = [\"hatchling\"]\n+ build-backend = \"hatchling.build\"\n</code></pre> </li> <li> <p>Add an entrypoint to your Python package. This tells Python how to execute your program. Add the following lines to your <code>pyproject.toml</code></p> <pre><code>+ [project.scripts]\n+ zit = \"zit.main:main\"\n</code></pre> </li> <li> <p>Install your package locally and run it</p> <p> <pre><code>$ uv pip install -e .\n$ zit --verbose\nSorry I don't know how to use git, it's too hard! ...\n</code></pre></p> </li> </ol>"},{"location":"packaging/#building-and-distributing-your-cli","title":"Building and distributing your CLI","text":"<p>I highly recommend you follow uv's guide on building an publishing packages.</p> <p>The TLDR is <code>uv build</code> then <code>uv publish</code>, but you'll want to set up your project with the right metadata. The official packaging Python guide is really good to configure all you'll need for distributing a quality package.</p>"},{"location":"packaging/#advanced-pre-built-binaries-shivs","title":"[Advanced] Pre-built binaries (Shivs \ud83d\udd2a)","text":"<p>Shiv's provide an easy way to bundle Python code into an executable file. Shiv's are, essentially, an executable zip file with Python files inside.</p> <p>To build a shiv with uv and clypi given the above <code>zit</code> example, run:</p> uvx shiv -c zit -o zit-bin ../zit-bin --verboseSorry I don't know how to use git, it's too hard! ... <p>You now have a binary (<code>zit-bin</code>) that you can distribute and run like any other binary. You'll have to manually add it to a <code>$PATH</code> location though (What is $PATH?).</p>"},{"location":"about/planned_work/","title":"Planned work","text":"<ul> <li> Support for better prompts (select, multi-select, etc.)</li> <li> Other simple UI components (e.g.: simple file tree)</li> <li> Testing tools -- Can we provide users with a good easy framework to test their CLI?</li> <li> Themes support -- How can users extend Formatter and/or select a theme?</li> <li> Strict Pyright -- Can this repo be entirely in strict mode?</li> <li> Better spinner interactions (capture and redirect stdout automatically)</li> <li> Better testing coverage (every parsing combination tested)</li> </ul>"},{"location":"about/why/","title":"Why Clypi?","text":"<p>I've been working with Python-based CLIs for several years with many users and strict quality requirements and always run into the sames problems with the go-to packages:</p> <ul> <li> <p>Argparse is the builtin solution for CLIs, but, as expected, it's functionality is very restrictive. It is not very extensible, it's UI is not pretty and very hard to change, lacks type checking and type parsers, and does not offer any modern UI components that we all love.</p> </li> <li> <p>Rich is too complex and threaded. The vast catalog of UI components they offer is amazing, but it is both easy to get wrong and break the UI, and too complicated/verbose to onboard coworkers to. It's prompting functionality is also quite limited and it does not offer command-line arguments parsing.</p> </li> <li> <p>Click is too restrictive. It enforces you to use decorators, which is great for locality of behavior but not so much if you're trying to reuse arguments across your application. It is also painful to deal with the way arguments are injected into functions and very easy to miss one, misspell, or get the wrong type. Click is also fully untyped for the core CLI functionality and hard to test.</p> </li> <li> <p>Typer seems great! I haven't personally tried it, but I have spent time looking through their docs and code. I think the overall experience is a step up from click's but, at the end of the day, it's built on top of it. Hence, many of the issues are the same: testing is hard, shared contexts are untyped, their built-in type parsing is quite limited, and it does not offer modern features like suggestions on typos. Using <code>Annotated</code> types is also very verbose inside function definitions.</p> </li> </ul> <p>Warning</p> <p>This section is my (danimelchor's) personal opinion I've gathered during my time working with Python CLIs. If you do not agree, please feel free to reach out and I'm open to discussing / trying out new tools.</p>"},{"location":"api/cli/","title":"CLI","text":""},{"location":"api/cli/#arg","title":"<code>arg</code>","text":"<pre><code>def arg(\n    default: T | Unset | EllipsisType = UNSET,\n    parser: Parser[T] | None = None,\n    default_factory: t.Callable[[], T] | Unset = UNSET,\n    help: str | None = None,\n    short: str | None = None,\n    prompt: str | None = None,\n    hide_input: bool = False,\n    max_attempts: int = MAX_ATTEMPTS,\n    negative: str | None = None,\n    group: str | None = None,\n    env: str | None = None,\n) -&gt; T\n</code></pre> <p>Utility function to configure how a specific argument should behave when displayed and parsed.</p> <p>Parameters:</p> <ul> <li><code>default</code>: the default value to return if the user doesn't pass in the argument (or hits enter during the prompt, if any)</li> <li><code>parser</code>: a function that takes in a string and returns the parsed type (see <code>Parser</code>)</li> <li><code>default_factory</code>: a function that returns a default value. Useful to defer computation or to avoid default mutable values</li> <li><code>help</code>: a brief description to show the user when they pass in <code>-h</code> or <code>--help</code></li> <li><code>short</code>: for options it defines a short way to pass in a value (e.g.: <code>short=\"v\"</code> allows users to pass in <code>-v &lt;value&gt;</code>)</li> <li><code>prompt</code>: if defined, it will ask the user to provide input if not already defined in the command line args</li> <li><code>hide_input</code>: whether the input shouldn't be displayed as the user types (for passwords, API keys, etc.)</li> <li><code>max_attempts</code>: how many times to ask the user before giving up and raising</li> <li><code>group</code>: optionally define the name of a group to display the option in. Adding an option will automatically display the options in a different section of the help page (see the Argument groups docs).</li> <li><code>negative</code>: defines the negative argument to set a flag as False. Useful for flags that have prompts so that they can be programmatically set to False.</li> <li><code>defer</code> (advanced): defers the fetching of a value until the value is used. This can be helpful to express complex dependencies between arguments. For example, you may not want to prompt if a different option was passed in (see <code>examples/cli_deferred.py</code>).</li> <li><code>env</code>: optionally define an environment variable to read the value from.</li> </ul>"},{"location":"api/cli/#command","title":"<code>Command</code>","text":"<p>This is the main class you must extend when defining a command. There are no methods you must override other than the <code>run</code> method.</p> <p>Clypi supports:</p> <ul> <li>Long options: <code>--foo 123</code> or <code>--foo=123</code></li> <li>Short options: <code>-f 123</code> or <code>-f=123</code></li> <li>Flags: <code>--verbose</code></li> <li>1.2.12 Concatenated short options: <code>-a -b -c</code> is the same as <code>-abc</code></li> <li>1.2.13 A double dash (<code>--</code>) stops parsing: <code>my-cli foo -- anything after is okay</code></li> </ul>"},{"location":"api/cli/#subcommands","title":"Subcommands","text":"<p>To define a subcommand, you must define a field in a class extending <code>Command</code> called <code>subcommand</code>. It's type hint must point to other classes extending <code>Command</code> or <code>None</code> by using either a single class, or a union of classes.</p> <p>These are all valid examples: <pre><code>from clypi import Command\n\nclass MySubcommand(Command):\n    pass\n\nclass MyOtherSubcommand(Command):\n    pass\n\nclass MyCommand(Command):\n    # A mandatory subcommand `my-subcommand`\n    subcommand: MySubcommand\n\n    # An optional subcommand `my-subcommand`\n    subcommand: MySubcommand | None\n\n    # A mandatory subcommand `my-subcommand` or `my-other-subcommand`\n    subcommand: MySubcommand | MyOtherSubcommand\n\n    # An optional subcommand `my-subcommand` or `my-other-subcommand`\n    subcommand: MySubcommand | MyOtherSubcommand | None\n</code></pre></p>"},{"location":"api/cli/#arguments-positional","title":"Arguments (positional)","text":"<p>Arguments are mandatory positional words the user must pass in. They're defined as class attributes with no default and type hinted with the <code>Positional[T]</code> type.</p> <pre><code>from clypi import Command, Positional\n\n# my-command 5 foo bar baz\n#        arg1^ ^^^^^^^^^^^arg2\nclass MyCommand(Command):\n    arg1: Positional[int]\n    arg2: Positional[list[str]]\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre>"},{"location":"api/cli/#flags","title":"Flags","text":"<p>Flags are boolean options that can be either present or not. To define a flag, simply define a boolean class attribute in your command with a default value. The user will then be able to pass in <code>--my-flag</code> when running the command which will set it to True.</p> <pre><code>from clypi import Command\n\n# With the flag ON: my-command --my-flag\n# With the flag OFF: my-command\nclass MyCommand(Command):\n    my_flag: bool = False\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre>"},{"location":"api/cli/#negative-flags","title":"Negative flags","text":"<p>You can define negative flag names for each flag using our handy <code>arg</code> helper and <code>negative</code>. This will configure an option users can pass that will set the flag to False. This is useful for flags that prompt so that they can be set to any value from the command line:</p> <pre><code>from clypi import Command, arg\n\n# With the flag ON: my-command --my-flag\n# With the flag OFF: my-command --no-my-flag\n# With no value: will prompt\nclass MyCommand(Command):\n    my_flag: bool = arg(False, prompt=\"Value for my-flag?\", negative=\"no_my_flag\")\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre>"},{"location":"api/cli/#options","title":"Options","text":"<p>Options are like flags but, instead of booleans, the user passes in specific values. You can think of options as key/pair items. Options can be set as required by not specifying a default value.</p> <pre><code>from clypi import Command\n\n# With value: my-command --my-attr foo\n# With default: my-command\nclass MyCommand(Command):\n    my_attr: str | int = \"some-default-here\"\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre>"},{"location":"api/cli/#running-the-command","title":"Running the command","text":"<p>You must implement the <code>run</code> method so that your command can be ran. The function must be <code>async</code> so that we can properly render items in your screen.</p> <pre><code>from clypi import Command\nfrom typing_extensions import override\n\nclass MyCommand(Command):\n    verbose: bool = False\n\n    @override\n    async def run(self):\n        print(f\"Running with verbose: {self.verbose}\")\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre>"},{"location":"api/cli/#help-page","title":"Help page","text":"<p>You can define custom help messages for each argument using our handy <code>arg</code> helper:</p> <pre><code>from clypi import Command, arg\n\nclass MyCommand(Command):\n    verbose: bool = arg(\n        True,\n        help=\"Whether to show all of the output\"\n    )\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre> <p>You can also define custom help messages for commands by creating a docstring on the class itself:</p> <pre><code>from clypi import Command\n\nclass MyCommand(Command):\n    \"\"\"\n    This text will show up when someone does `my-command --help`\n    and can contain any info you'd like\n    \"\"\"\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre>"},{"location":"api/cli/#prompting","title":"Prompting","text":"<p>If you want to ask the user to provide input if it's not specified, you can pass in a prompt to <code>arg</code> for each field like so:</p> <pre><code>from clypi import Command, arg\n\nclass MyCommand(Command):\n    name: str = arg(prompt=\"What's your name?\")\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre> <p>On runtime, if the user didn't provide a value for <code>--name</code>, the program will ask the user to provide one until they do. You can also pass in a <code>default</code> value to <code>arg</code> to allow the user to just hit enter to accept the default.</p>"},{"location":"api/cli/#autocomplete","title":"Autocomplete","text":"<p>All CLIs built with clypi come with a builtin <code>--install-autocomplete</code> option that will automatically set up shell completions for your built CLI.</p> <p>Warning</p> <p>This feature is brand new and might contain some bugs. Please file a ticket if you run into any!</p>"},{"location":"api/cli/#name","title":"<code>name</code>","text":"<p><pre><code>@t.final\n@classmethod\ndef prog(cls)\n</code></pre> The name of the command. Can be overridden to provide a custom name or will default to the class name extending <code>Command</code>.</p>"},{"location":"api/cli/#epilog","title":"<code>epilog</code>","text":"<p><pre><code>@t.final\n@classmethod\ndef epilog(cls)\n</code></pre> Optionally define text to display after the help message</p>"},{"location":"api/cli/#full_command","title":"<code>full_command</code>","text":"<p><pre><code>@t.final\n@classmethod\ndef full_command(cls)\n</code></pre> The full path of commands to the current command being ran.</p>"},{"location":"api/cli/#parents","title":"<code>parents</code>","text":"<p><pre><code>@t.final\n@classmethod\ndef parents(cls)\n</code></pre> A list of parent commands for this command.</p>"},{"location":"api/cli/#get_unparsed","title":"<code>get_unparsed</code>","text":"<p>1.2.13</p> <p><pre><code>@t.final\n@classmethod\ndef get_unparsed(cls)\n</code></pre> The list of unparsed arguments for this command. If a user passes in <code>--</code>, anything after the double dash will be left unparsed for the command to process as they wish.</p>"},{"location":"api/cli/#help","title":"<code>help</code>","text":"<p><pre><code>@t.final\n@classmethod\ndef help(cls)\n</code></pre> The help displayed for the command when the user passes in <code>-h</code> or <code>--help</code>. Defaults to the docstring for the class extending <code>Command</code>.</p>"},{"location":"api/cli/#run","title":"<code>run</code>","text":"<p><pre><code>async def run(self: Command) -&gt; None:\n</code></pre> The main function you must override. This function is where the business logic of your command should live.</p> <p><code>self</code> contains the arguments for this command you can access as you would do with any other instance property.</p>"},{"location":"api/cli/#astart-and-start","title":"<code>astart</code> and <code>start</code>","text":"<p><pre><code>async def astart(self: Command | None = None) -&gt; None:\n</code></pre> <pre><code>def start(self) -&gt; None:\n</code></pre> These commands are the entry point for your program. You can either call <code>YourCommand.start()</code> on your class or, if already in an async loop, <code>await YourCommand.astart()</code>.</p>"},{"location":"api/cli/#print_help","title":"<code>print_help</code>","text":"<p><pre><code>@classmethod\ndef print_help(cls, exception: Exception | None = None)\n</code></pre> Prints the help page for a particular command.</p> <p>Parameters:</p> <ul> <li><code>exception</code>: an exception neatly showed to the user as a traceback. Automatically passed in during runtime.</li> </ul>"},{"location":"api/cli/#pre_run_hook","title":"<code>pre_run_hook</code>","text":"<p>1.2.7</p> <p><pre><code>async def pre_run_hook(self: Command) -&gt; None:\n</code></pre> A function that will run on every parent command and subcommand right before it's execution. Useful to print before commands, emit metrics, and more!</p> <p>Examples:</p> <pre><code>import logging\nfrom typing_extensions import override\nfrom clypi import Command\n\nclass MyCommand(Command):\n    @override\n    async def pre_run_hook(self):\n        cmd_str = \" \".join(self.full_command())\n        logging.debug(\"Running %s\", cmd_str)\n\n    @override\n    async def run(self):\n        print(\"Hey\")\n\nmain = MyCommand.parse()\nmain.start()\n</code></pre>"},{"location":"api/cli/#post_run_hook","title":"<code>post_run_hook</code>","text":"<p>1.2.7</p> <p><pre><code>async def post_run_hook(self: Command, exception: Exception | None) -&gt; None:\n</code></pre> A function that will run on every parent command and subcommand right after it's execution. Useful to print after commands, process exceptions, emit metrics, and more!</p>"},{"location":"api/cli/#formatter","title":"<code>Formatter</code>","text":"<p>A formatter is any class conforming to the following protocol. It is called on several occasions to render the help page. The <code>Formatter</code> implementation should try to use the provided configuration theme when possible.</p> <pre><code>class Formatter(t.Protocol):\n    def format_help(\n        self,\n        full_command: list[str],\n        description: str | None,\n        epilog: str | None,\n        options: list[Argument],\n        positionals: list[Argument],\n        subcommands: list[type[Command]],\n        exception: Exception | None,\n    ) -&gt; str: ...\n</code></pre>"},{"location":"api/cli/#clypiformatter","title":"<code>ClypiFormatter</code>","text":"<p><pre><code>class ClypiFormatter(\n    boxed=True,\n    show_option_types=False,\n    show_inherited_options=True,\n    normalize_dots=\"\",\n)\n</code></pre> Parameters:</p> <ul> <li><code>boxed</code>: whether to wrap each section in a box made with ASCII characters</li> <li><code>show_option_types</code>: whether to display the expected type for each argument or just a placeholder. E.g.: <code>--foo TEXT</code> vs <code>--foo &lt;FOO&gt;</code></li> <li><code>show_inherited_options</code>: whether to show inherited arguments in child commands or only in parent commands</li> <li><code>normalize_dots</code>: either <code>\".\"</code>, <code>\"\"</code>, or <code>None</code>. If a dot, or empty, it will add or remove trailing dots from all help messages to keep a more consistent formatting across the application.</li> </ul> <p>Clypi ships with a pre-made formatter that can display help pages with either boxes or with indented sections, and hideor show the option types. You can disable both the boxes and type of each option and display just a placeholder.</p> <p>With everything enabled:</p> <pre><code>ClypiFormatter(boxed=True, show_option_types=True)\n</code></pre> <p></p> <p>With everything disabled:</p> <pre><code>ClypiFormatter(boxed=False, show_option_types=False)\n</code></pre> <p></p>"},{"location":"api/colors/","title":"Colors","text":"<p>Tip</p> <p>Follow the Beautiful UIs guide for examples.!</p>"},{"location":"api/colors/#colortype","title":"<code>ColorType</code>","text":"<pre><code>ColorType: t.TypeAlias = t.Literal[\n    \"black\",\n    \"red\",\n    \"green\",\n    \"yellow\",\n    \"blue\",\n    \"magenta\",\n    \"cyan\",\n    \"white\",\n    \"default\",\n    \"bright_black\",\n    \"bright_red\",\n    \"bright_green\",\n    \"bright_yellow\",\n    \"bright_blue\",\n    \"bright_magenta\",\n    \"bright_cyan\",\n    \"bright_white\",\n    \"bright_default\",\n]\n</code></pre>"},{"location":"api/colors/#styler","title":"<code>Styler</code>","text":"<p><pre><code>class Styler(\n    fg: ColorType | None = None,\n    bg: ColorType | None = None,\n    bold: bool = False,\n    italic: bool = False,\n    dim: bool = False,\n    underline: bool = False,\n    blink: bool = False,\n    reverse: bool = False,\n    strikethrough: bool = False,\n    reset: bool = False,\n    hide: bool = False,\n)\n</code></pre> Returns a reusable function to style text.</p>"},{"location":"api/colors/#style","title":"<code>style</code>","text":"<p><pre><code>def style(\n    *messages: t.Any,\n    fg: ColorType | None = None,\n    bg: ColorType | None = None,\n    bold: bool = False,\n    italic: bool = False,\n    dim: bool = False,\n    underline: bool = False,\n    blink: bool = False,\n    reverse: bool = False,\n    strikethrough: bool = False,\n    reset: bool = False,\n    hide: bool = False,\n) -&gt; str\n</code></pre> Styles text and returns the styled string.</p>"},{"location":"api/colors/#print","title":"<code>print</code>","text":"<p><pre><code>def cprint(\n    *messages: t.Any,\n    fg: ColorType | None = None,\n    bg: ColorType | None = None,\n    bold: bool = False,\n    italic: bool = False,\n    dim: bool = False,\n    underline: bool = False,\n    blink: bool = False,\n    reverse: bool = False,\n    strikethrough: bool = False,\n    reset: bool = False,\n    hide: bool = False,\n    file: SupportsWrite | None = None,\n    end: str | None = \"\\n\",\n) -&gt; None\n</code></pre> Styles and prints colored and styled text directly.</p>"},{"location":"api/components/","title":"UI Components","text":"<p>Tip</p> <p>Follow the Beautiful UIs guide for examples.!</p>"},{"location":"api/components/#spinners","title":"Spinners","text":""},{"location":"api/components/#spin","title":"<code>Spin</code>","text":"<pre><code>class Spin(Enum): ...\n</code></pre> <p>The spinning animation you'd like to use. The spinners are sourced from the NPM cli-spinners package.</p> <p>You can see all the spinners in action by running <code>uv run -m examples.spinner</code>. The full list can be found in the code here.</p>"},{"location":"api/components/#spinner","title":"<code>Spinner</code>","text":"<p>A spinner indicating that something is happening behind the scenes. It can be used as a context manager or like a decorator. The context manager usage is like so:</p> <pre><code>import asyncio\nfrom clypi import Spinner\n\nasync def main():\n    async with Spinner(\"Doing something\", capture=True) as s:\n        await asyncio.sleep(1)\n        s.title = \"Slept for a bit\"\n        print(\"I slept for a bit, will sleep a bit more\")\n        await asyncio.sleep(1)\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/components/#spinner__init__","title":"<code>Spinner.__init__()</code>","text":"<p><pre><code>def __init__(\n    self,\n    title: str,\n    animation: Spin | list[str] = Spin.DOTS,\n    prefix: str = \" \",\n    suffix: str = \"\u2026\",\n    speed: float = 1,\n    capture: bool = False,\n    output: t.Literal[\"stdout\", \"stderr\"] = \"stderr\",\n)\n</code></pre> Parameters:</p> <ul> <li><code>title</code>: the initial text to display as the spinner spins</li> <li><code>animation</code>: a provided <code>Spin</code> animation or a list of frames to display</li> <li><code>prefix</code>: text or padding displayed before the icon</li> <li><code>suffix</code>: text or padding displayed after the icon</li> <li><code>speed</code>: a multiplier to speed or slow down the frame rate of the animation</li> <li><code>capture</code>: if enabled, the Spinner will capture all stdout and stderr and display it nicely</li> <li><code>output</code>: the pipe to write the spinner animation to</li> </ul>"},{"location":"api/components/#done","title":"<code>done</code>","text":"<p><pre><code>async def done(self, msg: str | None = None)\n</code></pre> Mark the spinner as done early and optionally display a message.</p>"},{"location":"api/components/#fail","title":"<code>fail</code>","text":"<p><pre><code>async def fail(self, msg: str | None = None)\n</code></pre> Mark the spinner as failed early and optionally display an error message.</p>"},{"location":"api/components/#log","title":"<code>log</code>","text":"<p><pre><code>async def log(self, msg: str | None = None)\n</code></pre> Display extra log messages to the user as the spinner spins and your work progresses.</p>"},{"location":"api/components/#pipe","title":"<code>pipe</code>","text":"<p><pre><code>async def pipe(\n    self,\n    pipe: asyncio.StreamReader | None,\n    color: ColorType = \"blue\",\n    prefix: str = \"\",\n)\n</code></pre> Pipe the output of an async subprocess into the spinner and display the stdout or stderr with a particular color and prefix.</p> <p>Examples:</p> <pre><code>import asyncio\n\nasync def main():\n    async with Spinner(\"Doing something\") as s:\n        proc = await asyncio.create_subprocess_shell(\n            \"for i in $(seq 1 10); do date &amp;&amp; sleep 0.4; done;\",\n            stdout=asyncio.subprocess.PIPE,\n            stderr=asyncio.subprocess.PIPE,\n        )\n        await asyncio.gather(\n            s.pipe(proc.stdout, color=\"blue\", prefix=\"(stdout)\"),\n            s.pipe(proc.stderr, color=\"red\", prefix=\"(stdout)\"),\n        )\n</code></pre>"},{"location":"api/components/#spinner-decorator","title":"<code>spinner</code> (decorator)","text":"<p>This is just a utility decorator that let's you wrap functions so that a spinner displays while they run. <code>spinner</code> accepts the same arguments as the context manager <code>Spinner</code>.</p> <pre><code>import asyncio\nfrom clypi import spinner\n\n@spinner(\"Doing work\", capture=True)\nasync def do_some_work():\n    await asyncio.sleep(2)\n\nasyncio.run(do_some_work())\n</code></pre>"},{"location":"api/components/#boxed","title":"Boxed","text":""},{"location":"api/components/#boxes","title":"<code>Boxes</code>","text":"<pre><code>class Boxes(Enum): ...\n</code></pre> <p>The border style you'd like to use. To see all the box styles in action run <code>uv run -m examples.boxed</code>.</p> <p>The full list can be found in the code here.</p>"},{"location":"api/components/#boxed_1","title":"<code>boxed</code>","text":"<p><pre><code>def boxed(\n    lines: T,\n    width: t.Literal[\"auto\", \"max\"] | int = \"auto\",\n    style: Boxes = Boxes.HEAVY,\n    alignment: AlignType = \"left\",\n    title: str | None = None,\n    color: ColorType = \"bright_white\",\n) -&gt; T:\n</code></pre> Wraps text neatly in a box with the selected style, padding, and alignment.</p> <p>Parameters:</p> <ul> <li><code>lines</code>: the type of lines will determine it's output type. It can be one of <code>str</code>, <code>list[str]</code> or <code>Iterable[str]</code></li> <li><code>width</code>: the desired width of the box:<ul> <li>If <code>\"max\"</code>, it will be set to the max width of the terminal.</li> <li>If <code>\"auto\"</code>, it will be set to the max width of the content.</li> <li>If <code>width &lt; 0</code>, it will be set to the max width of the terminal - the number.</li> <li>If <code>width &gt; 0</code>, it will be set to that exact width.</li> </ul> </li> <li><code>style</code>: the desired style (see <code>Boxes</code>)</li> <li><code>alignment</code>: the style of alignment (see <code>align</code>)</li> <li><code>title</code>: optionally define a title for the box, it's length must be &lt; width</li> <li><code>color</code>: a color for the box border and title (see <code>colors</code>)</li> </ul>"},{"location":"api/components/#stack","title":"Stack","text":"<pre><code>def stack(*blocks: list[str], width: int | None = None, padding: int = 1) -&gt; str:\ndef stack(*blocks: list[str], width: int | None = None, padding: int = 1, lines: bool) -&gt; list[str]:\n</code></pre> <p>Horizontally aligns blocks of text to display a nice layout where each block is displayed side by side.</p> <p>Parameters:</p> <ul> <li><code>blocks</code>: a series of blocks of lines of strings to display side by side</li> <li><code>width</code>: the desired width of the box. If None, it will be set to the max width of the terminal. If negative, it will be set to the max width of the terminal - the number.</li> <li><code>padding</code>: the space between each block</li> <li><code>lines</code>: if the output should be returned as lines or as a string</li> </ul>"},{"location":"api/components/#separator","title":"Separator","text":""},{"location":"api/components/#separator_1","title":"<code>separator</code>","text":"<p><pre><code>def separator(\n    separator: str = \"\u2501\",\n    width: t.Literal[\"max\"] | int = \"max\",\n    title: str | None = None,\n    color: ColorType | None = None,\n) -&gt; str:\n</code></pre> Prints a line made of the given separator character.</p> <p>Parameters:</p> <ul> <li><code>separator</code>: the character used to build the separator line</li> <li><code>width</code>: if <code>max</code> it will use the max size of the terminal. Otherwise you can provide a fixed width.</li> <li><code>title</code>: optionally provide a title to display in the middle of the separator</li> <li><code>color</code>: the color for the characters</li> </ul>"},{"location":"api/components/#indented","title":"Indented","text":""},{"location":"api/components/#indented_1","title":"<code>indented</code>","text":"<p><pre><code>def indented(lines: list[str], prefix: str = \"  \") -&gt; list[str]\n</code></pre> Indents a set of lines with the given prefix</p>"},{"location":"api/components/#align","title":"Align","text":""},{"location":"api/components/#align_1","title":"<code>align</code>","text":"<p><pre><code>def align(s: str, alignment: AlignType, width: int) -&gt; str\n</code></pre> Aligns text according to <code>alignment</code> and <code>width</code>. In contrast with the built-in methods <code>rjust</code>, <code>ljust</code>, and <code>center</code>, <code>clypi.align(...)</code> aligns text according to it's true visible width (the built-in methods count color codes as width chars).</p> <p>Parameters:</p> <ul> <li><code>s</code>: the string being aligned</li> <li><code>alignment</code>: one of <code>left</code>, <code>right</code>, or <code>center</code></li> <li><code>width</code>: the wished final visible width of the string</li> </ul> <p>Examples:</p> <pre><code>import clypi\n\n clypi.align(\"foo\", \"left\", 10) # -&gt; \"foo       \"\n clypi.align(\"foo\", \"right\", 10) # -&gt; \"          foo\"\n clypi.align(\"foo\", \"center\", 10) # -&gt; \"   foo   \"\n</code></pre>"},{"location":"api/config/","title":"Configuration","text":""},{"location":"api/config/#accessing-and-changing-the-configuration","title":"Accessing and changing the configuration","text":"<pre><code>from clypi import ClypiConfig, configure, get_config\n\n# Gets the current config (or a default)\nconf = get_config()\n\n# Change the configuration\nconfig = ClypiConfig(help_on_fail=False)\nconfigure(config)\n</code></pre>"},{"location":"api/config/#default-config","title":"Default config","text":"<pre><code>ClypiConfig(\n    help_formatter=ClypiFormatter(\n        boxed=True,\n        show_option_types=True,\n    ),\n    help_on_fail=True,\n    nice_errors=(ClypiException,),\n    theme=Theme(\n        usage=Styler(fg=\"yellow\"),\n        usage_command=Styler(bold=True),\n        usage_args=Styler(),\n        section_title=Styler(),\n        subcommand=Styler(fg=\"blue\", bold=True),\n        long_option=Styler(fg=\"blue\", bold=True),\n        short_option=Styler(fg=\"green\", bold=True),\n        positional=Styler(fg=\"blue\", bold=True),\n        placeholder=Styler(fg=\"blue\"),\n        type_str=Styler(fg=\"yellow\", bold=True),\n        prompts=Styler(fg=\"blue\", bold=True),\n    ),\n    overflow_style=\"wrap\",\n    disable_colors=False,\n    fallback_term_width=100,\n)\n</code></pre> <p>Parameters:</p> <ul> <li><code>help_formatter</code>: the formatter class to use to display the help pages (see Formatter)</li> <li><code>help_on_fail</code>: whether the help page should be displayed if a user doesn't pass the right params</li> <li><code>nice_errors</code>: a list of errors clypi will catch and display neatly</li> <li><code>theme</code>: a <code>Theme</code> object used to format different styles and colors for help pages, prompts, tracebacks, etc.</li> <li><code>overflow_style</code>: either <code>wrap</code> or <code>ellipsis</code>. If wrap, text that is too long will get wrapped into the next line. If ellipsis, the text will be truncated with an <code>\u2026</code> at the end</li> <li>1.2.11 <code>disable_colors</code>: whether we should disable all colors and text styles</li> <li>1.2.11 <code>fallback_term_width</code>: if we cannot get the current terminal width (e.g.: subprocesses, non-tty devices, etc.), what should the fallback terminal width be (mostly used for displaying errors)</li> </ul>"},{"location":"api/parsers/","title":"Parsers","text":"<p>For this section, parsers will be imported as such: <pre><code>import clypi.parsers as cp\n</code></pre></p>"},{"location":"api/parsers/#int","title":"<code>Int</code>","text":"<p>The <code>Int</code> parser converts string input into an integer.</p> <pre><code>Int(\n    gt: int | None = None,\n    gte: int | None = None,\n    lt: int | None = None,\n    lte: int | None = None,\n    max: int | None = None,\n    min: int | None = None,\n    positive: bool = False,\n    nonpositive: bool = False,\n    negative: bool = False,\n    nonnegative: bool = False,\n</code></pre> <p>Parameters:</p> <ul> <li><code>gt</code>: A value the integer must be greater than</li> <li><code>gte</code>: A value the integer must be greater than or equal to</li> <li><code>lt</code>: A value the integer must be less than</li> <li><code>lte</code>: A value the integer must be less than or equal to</li> <li><code>max</code>: The maximum value the integer can be (same as lte)</li> <li><code>min</code>: The maximum value the integer can be (same as gte)</li> <li><code>positive</code>: The integer must be greater than 0</li> <li><code>nonpositive</code>: The integer must be less than or equal to 0</li> <li><code>negative</code>: The integer must be less than 0</li> <li><code>nonnegative</code>: The integer must be greater than or equal to 0</li> </ul> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\nparser = cp.Int(lte=10, gt=2)\nassert parser(\"3\") == 3\nassert_raises(lambda: parser(\"2\"))  # Not &gt;2\nassert_raises(lambda: parser(\"11\"))  # Not &lt;=10\n</code></pre>"},{"location":"api/parsers/#float","title":"<code>Float</code>","text":"<p>The <code>Float</code> parser converts string input into a floating-point number.</p> <p><pre><code>Float(\n    gt: float | None = None,\n    gte: float | None = None,\n    lt: float | None = None,\n    lte: float | None = None,\n    max: float | None = None,\n    min: float | None = None,\n    positive: bool = False,\n    nonpositive: bool = False,\n    negative: bool = False,\n    nonnegative: bool = False,\n)\n</code></pre> Parameters:</p> <ul> <li><code>gt</code>: A value the float must be greater than</li> <li><code>gte</code>: A value the float must be greater than or equal to</li> <li><code>lt</code>: A value the float must be less than</li> <li><code>lte</code>: A value the float must be less than or equal to</li> <li><code>max</code>: The maximum value the float can be (same as lte)</li> <li><code>min</code>: The maximum value the float can be (same as gte)</li> <li><code>positive</code>: The float must be greater than 0</li> <li><code>nonpositive</code>: The float must be less than or equal to 0</li> <li><code>negative</code>: The float must be less than 0</li> <li><code>nonnegative</code>: The float must be greater than or equal to 0</li> </ul> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\nparser = cp.Float(lte=10, gt=2)\nassert parser(\"3\") == 3\nassert parser(\"2.01\") == 2.01\nassert_raises(lambda: parser(\"2\"))  # Not &gt;2\nassert_raises(lambda: parser(\"11\"))  # Not &lt;=10\n</code></pre>"},{"location":"api/parsers/#bool","title":"<code>Bool</code>","text":"<p>The <code>Bool</code> parser converts string input into a boolean.</p> <pre><code>Bool()\n</code></pre> <p>Accepted values: - <code>true</code>, <code>yes</code>, <code>y</code> \u2192 <code>True</code> - <code>false</code>, <code>no</code>, <code>n</code> \u2192 <code>False</code></p> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\nparser = cp.Bool()\nassert parser(\"y\") is True\nassert parser(\"NO\") is False\n</code></pre>"},{"location":"api/parsers/#str","title":"<code>Str</code>","text":"<p>The <code>Str</code> parser returns the string input as-is.</p> <p><pre><code>Str(\n    length: int | None = None,\n    max: int | None = None,\n    min: int | None = None,\n    startswith: str | None = None,\n    endswith: str | None = None,\n    regex: str | None = None,\n    regex_group: int | None = None,\n)\n</code></pre> Parameters:</p> <ul> <li><code>length</code>: The string must be of this length</li> <li><code>max</code>: The string's length must be at most than this number</li> <li><code>min</code>: The string's length must be at least than this number</li> <li><code>startswith</code>: The string must start with that substring</li> <li><code>endsswith</code>: The string must end with that substring</li> <li><code>regex</code>: The string must match this regular expression</li> <li><code>regex_group</code>: (required <code>regex</code>) extracts the group from the regular expression</li> </ul> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\nparser = cp.Str(regex=r\"[a-z]([0-9]+)\", regex_group=1)\nassert parser(\"f1\") == \"1\"\nassert parser(\"f123\") == \"123\"\nassert_raises(lambda: parser(\"123f\"))\nassert_raises(lambda: parser(\"f\"))\n</code></pre>"},{"location":"api/parsers/#datetime","title":"<code>DateTime</code>","text":"<p>The <code>DateTime</code> parser converts string input into a <code>datetime</code> object.</p> <p><pre><code>DateTime(\n    tz: timezone | None = None,\n)\n</code></pre> Parameters:</p> <ul> <li><code>tz</code>: the timezone to convert the date to. If the date is provided without a timezone, it will be forced as the specified one. If it's passed with a timezone, it will convert the date to the right offset.</li> </ul>"},{"location":"api/parsers/#timedelta","title":"<code>TimeDelta</code>","text":"<p>The <code>TimeDelta</code> parser converts string input into a <code>timedelta</code> object.</p> <p><pre><code>TimeDelta(\n    gt: timedelta | None = None,\n    gte: timedelta | None = None,\n    lt: timedelta | None = None,\n    lte: timedelta | None = None,\n    max: timedelta | None = None,\n    min: timedelta | None = None,\n)\n</code></pre> - <code>gt</code>: A value the timedelta must be greater than - <code>gte</code>: A value the timedelta must be greater than or equal to - <code>lt</code>: A value the timedelta must be less than - <code>lte</code>: A value the timedelta must be less than or equal to - <code>max</code>: The maximum value the timedelta can be (same as lte) - <code>min</code>: The maximum value the timedelta can be (same as gte)</p> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\nparser = cp.TimeDelta(gte=timedelta(days=1))\nassert parser(\"1 day\") == timedelta(days=1)\nassert parser(\"1w\") == timedelta(weeks=1)\nassert_raises(lambda: parser(\"23h\")) # Under 1 day\n</code></pre> <p>Supported time units: - <code>weeks (w)</code>, <code>days (d)</code>, <code>hours (h)</code>, <code>minutes (m)</code>, <code>seconds (s)</code>, <code>milliseconds (ms)</code>, <code>microseconds (us)</code></p>"},{"location":"api/parsers/#path","title":"<code>Path</code>","text":"<p>The <code>Path</code> parser is useful to parse file or directory-like arguments from the CLI.</p> <p><pre><code>Path(exists: bool | None = None)\n</code></pre> Parameters:</p> <ul> <li><code>exists</code>: If <code>True</code>, it ensures the provided path exists. If <code>False</code>, it ensures the provided path does not exist.</li> </ul> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\ncp.Path(exists=True)\n</code></pre>"},{"location":"api/parsers/#list","title":"<code>List</code>","text":"<p>The <code>List</code> parser parses comma-separated values into a list of parsed elements. The CLI parser will, by default, pass in multiple arguments as a list of strings to the top-level <code>List</code> parser. Nested items will be parsed by splitting the string by commas.</p> <pre><code>List(inner: Parser[T])\n</code></pre> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\n# list[int]\n# E.g.: --foo 1 2 3\nparser = cp.List(cp.Int())\nassert parser([\"1\", \"2\", \"3\"]) == [1, 2, 3]\nassert parser(\"1, 2, 3\") == [1, 2, 3]\n\n# list[list[int]]\n# E.g.: --foo 1,2 2,3 3,4\nparser = cp.List(cp.List(cp.Int()))\nassert parser([\"1,2\", \"2,3\", \"3, 4\"]) == [\n    [1, 2],\n    [2, 3],\n    [3, 4],\n]\n</code></pre> <p>Parameters:</p> <ul> <li><code>inner</code>: The parser used to convert each list element.</li> </ul>"},{"location":"api/parsers/#tuple","title":"<code>Tuple</code>","text":"<p>The <code>Tuple</code> parser parses a string input into a tuple of values. The tuple parser will split the input string by commas.</p> <pre><code>Tuple(*inner: Parser, num: int | None = None)\n</code></pre> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\n# tuple[str, ...]\n# E.g.: --foo a,b,c\nparser = cp.Tuple(cp.Str(), num=None)\nassert parser([\"a\", \"b\", \"c\"]) == (\"a\", \"b\", \"c\")\nassert parser(\"a,b,c\") == (\"a\", \"b\", \"c\")\n\n# tuple[str, int]\n# E.g.: --foo a,2\nparser = cp.Tuple(cp.Str(), cp.Int())\nassert parser([\"a\", \"2\"]) == (\"a\", 2)\nassert parser(\"a,2\") == (\"a\", 2)\n\n# list[tuple[str, int]]\n# E.g.: --foo a,2 b,3 c,4\nparser = cp.List(cp.Tuple(cp.Str(), cp.Int()))\nassert parser([\"a,2\", \"b,3\", \"c, 4\"]) == [\n    (\"a\", 2),\n    (\"b\", 3),\n    (\"c\", 4),\n]\n</code></pre> <p>Parameters:</p> <ul> <li><code>inner</code>: List of parsers for each tuple element.</li> <li><code>num</code>: Expected tuple length. If None, the tuple will accept unlimited arguments (equivalent to <code>tuple[&lt;type&gt;, ...]</code>)</li> </ul>"},{"location":"api/parsers/#union","title":"<code>Union</code>","text":"<p>The <code>Union</code> parser attempts to parse input using multiple parsers.</p> <pre><code>Union(left: Parser[X], right: Parser[Y])\n</code></pre> <p>You can also use the short hand <code>|</code> syntax for two parsers, e.g.:</p> <pre><code>import clypi.parsers as cp\nfrom pathlib import Path\n\nparser = cp.Union(cp.Path(exists=True), cp.Int())\nparser = cp.Path(exists=True) | cp.Int()\nassert parser(\"README.md\") == Path(\"README.md\")\nassert parser(\"1\") == 1\nassert_raises(lambda: parser(\"foo\"))\n</code></pre>"},{"location":"api/parsers/#literal","title":"<code>Literal</code>","text":"<p>The <code>Literal</code> parser ensures that input matches one of the predefined values.</p> <pre><code>Literal(*values: t.Any)\n</code></pre> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\nparser = cp.Literal(1, \"foo\")\nassert parser(\"1\") == 1\nassert parser(\"foo\") == \"foo\"\nassert_raises(lambda: parser(\"bar\"))\n</code></pre>"},{"location":"api/parsers/#enum","title":"<code>Enum</code>","text":"<p>The <code>Enum</code> parser maps string input to a valid enum value.</p> <pre><code>Enum(enum: type[enum.Enum])\n</code></pre> <p>Examples:</p> <pre><code>import clypi.parsers as cp\nfrom enum import Enum\n\nclass Color(Enum):\n    RED = 1\n    BLUE = 2\n\nparser = cp.Enum(Color)\nassert parser(\"red\") == Color.RED\nassert parser(\"blue\") == Color.BLUE\nassert_raises(lambda: parser(\"green\"))\n</code></pre>"},{"location":"api/parsers/#from_type","title":"<code>from_type</code>","text":"<p>The <code>from_type</code> function returns the appropriate parser for a given type.</p> <pre><code>@tu.ignore_annotated\ndef from_type(_type: type) -&gt; Parser: ...\n</code></pre> <p>Examples:</p> <pre><code>import clypi.parsers as cp\n\nassert cp.from_type(bool) == cp.Bool()\n</code></pre>"},{"location":"api/parsers/#supported-built-in-types","title":"Supported built-in types","text":"<ul> <li><code>None</code> <code>cp.NoneParser()</code></li> <li><code>bool</code> <code>cp.Bool()</code></li> <li><code>int</code> <code>cp.Int()</code></li> <li><code>float</code> <code>cp.Float()</code></li> <li><code>str</code> <code>cp.Str()</code></li> <li><code>Path</code> <code>cp.Path()</code></li> <li><code>datetime</code> <code>cp.DateTime()</code></li> <li><code>timedelta</code> <code>cp.TimeDelta()</code></li> <li><code>Enum</code> <code>cp.Enum(&lt;type&gt;)</code></li> <li><code>list[&lt;type&gt;]</code> <code>cp.List(&lt;type&gt;)</code>. E.g.:<ul> <li><code>list[str]</code> <code>cp.List(cp.Str())</code>)</li> </ul> </li> <li><code>tuple[&lt;type(s)&gt;]</code> <code>cp.Tuple(&lt;type&gt;, &lt;len&gt;)</code>. E.g.:<ul> <li><code>tuple[str]</code> <code>cp.Tuple(cp.Str())</code>)</li> <li><code>tuple[str, int]</code> <code>cp.Tuple(cp.Str(), cp.Int())</code>)</li> <li><code>tuple[str, ...]</code> <code>cp.Tuple(cp.Str(), num=None)</code>)</li> </ul> </li> <li><code>Union[&lt;type(s)&gt;]</code> <code>cp.Union(*&lt;type(s)&gt;)</code>. E.g.:<ul> <li><code>str | None</code> <code>cp.Union(cp.Str(), cp.NoneParser())</code>)</li> <li><code>str | bool | int</code> <code>cp.Union(cp.Str(), cp.Bool(), cp.Int())</code>)</li> </ul> </li> <li>1.2.15 <code>Optional[&lt;type&gt;]</code> <code>cp.Union(&lt;type&gt;, cp.NoneParser())</code>. E.g.:<ul> <li><code>Optional[str]</code> <code>cp.Union(cp.Str(), cp.NoneParser())</code>)</li> </ul> </li> <li>1.2.17 <code>Literal[&lt;value(s)&gt;]</code> <code>cp.Literal(*&lt;value(s)&gt;)</code>. E.g.:<ul> <li><code>Literal[1, \"foo\"]</code> <code>cp.Literal(1, \"foo\")</code>)</li> </ul> </li> </ul>"},{"location":"api/prompts/","title":"Prompts","text":""},{"location":"api/prompts/#parsert","title":"<code>Parser[T]</code>","text":"<p><pre><code>Parser: TypeAlias = Callable[[Any], T] | type[T]\n</code></pre> A function taking in any value and returns a value of type <code>T</code>. This parser can be a user defined function, a built-in type like <code>str</code>, <code>int</code>, etc., or a parser from a library.</p>"},{"location":"api/prompts/#confirm","title":"<code>confirm</code>","text":"<p><pre><code>def confirm(\n    text: str,\n    *,\n    default: bool | Unset = UNSET,\n    max_attempts: int = MAX_ATTEMPTS,\n    abort: bool = False,\n) -&gt; bool:\n</code></pre> Prompts the user for a yes/no value.</p> <p>Parameters:</p> <ul> <li><code>text</code>: the text to display to the user when asking for input</li> <li><code>default</code>: optionally set a default value that the user can immediately accept</li> <li><code>max_attempts</code>: how many times to ask the user before giving up and raising</li> <li><code>abort</code>: if a user answers \"no\", it will raise a <code>AbortException</code></li> </ul>"},{"location":"api/prompts/#prompt","title":"<code>prompt</code>","text":"<p><pre><code>def prompt(\n    text: str,\n    default: T | Unset = UNSET,\n    parser: Parser[T] = str,\n    hide_input: bool = False,\n    max_attempts: int = MAX_ATTEMPTS,\n) -&gt; T:\n</code></pre> Prompts the user for a value and uses the provided parser to validate and parse the input</p> <p>Parameters:</p> <ul> <li><code>text</code>: the text to display to the user when asking for input</li> <li><code>default</code>: optionally set a default value that the user can immediately accept</li> <li><code>parser</code>: a function that parses in the user input as a string and returns the parsed value or raises</li> <li><code>hide_input</code>: whether the input shouldn't be displayed as the user types (for passwords, API keys, etc.)</li> <li><code>max_attempts</code>: how many times to ask the user before giving up and raising</li> </ul>"},{"location":"learn/advanced_arguments/","title":"Advanced Arguments","text":""},{"location":"learn/advanced_arguments/#argument-inheritance","title":"Argument inheritance","text":"<p>Say you have arguments that you want every command to be able to use but you want to avoid having to copy paste their definition over and over on every command. Clypi provides an intuitive solution for this issue: argument inheritance.</p> <p>The idea is easy: define the arguments in a parent command and all children will be able to use them without having to redefine them.</p> cli.py<pre><code>from clypi import Command, Positional, arg\nfrom typing_extensions import override\n\nclass Wave(Command):\n    \"\"\"Wave at someone\"\"\"\n    name: Positional[str]\n    verbose: bool = arg(inherited=True)\n\n    @override\n    async def run(self) -&gt; None:\n        print(f\"\ud83d\udc4b Hey {self.name}\")\n        if self.verbose:\n            print(f\"\ud83d\udc4b\ud83d\udc4b\ud83d\udc4b HEYYY {self.name}\")\n\nclass Cli(Command):\n    \"\"\"A very simple CLI\"\"\"\n    subcommand: Wave | None\n    verbose: bool = arg(\n        False, short=\"v\", help=\"Whether to show verbose output\", group=\"global\"\n    )\n\nif __name__ == \"__main__\":\n    cmd = Cli.parse()\n    cmd.start()\n</code></pre> <p>You will see even though the help message for <code>verbose</code> is defined in the parent command, the subcommand <code>Wave</code> gets the entire argument definition for free:</p> python cli.py wave --helpWave at someoneUsage: cli wave [NAME] [OPTIONS]\u250f\u2501 Arguments \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 [NAME]                                                                       \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\u250f\u2501 Global options \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 -v, --verbose   Whether to show verbose output                               \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251bpython cli.py Daniel\ud83d\udc4b Hey Danielpython cli.py Daniel -v\ud83d\udc4b Hey Daniel\ud83d\udc4b\ud83d\udc4b\ud83d\udc4b HEYYY Daniel"},{"location":"learn/advanced_arguments/#deferring-arguments","title":"Deferring arguments","text":"<p>CLIs can get very complex. Sometimes we want to build a complex graph of dependencies between the arguments and it is hard to do that. For example, we can have an application that does not use <code>--num-cores</code> if <code>--single-threaded</code> was provided already. For that, clypi offers <code>arg(defer=True)</code>.</p> <p>The internals are complex but the user experience is quite simple: clypi will not prompt or require this value being passed up until when it's executed.</p> <pre><code>from clypi import Command, arg\nfrom typing_extensions import override\n\nclass Cli(Command):\n    single_threaded: bool = arg(False)\n    num_cores: int = arg(\n        defer=True,\n        prompt=\"How many CPU cores do you want to use?\"\n    )\n\n    @override\n    async def run(self):\n        print(f\"Running single theaded:\", self.single_threaded)  # &lt;&lt; will not prompt yet...\n        if self.single_threaded:\n            # if we never access num_cores in this if condition, we will\n            # never prompt!\n            print(\"Running single threaded...\")\n        else:\n            threads = self.num_cores // 4  # &lt;&lt; we prompt here!\n            print(\"Running with threads:\", threads)\n\nif __name__ == \"__main__\":\n    cmd = Cli.parse()  # &lt;&lt; will not prompt yet...\n    cmd.start()  # &lt;&lt; will not prompt yet...\n</code></pre> <p>As you can see, we are prompted only if we do not specify <code>--single-threaded</code> and only after we've printed the <code>\"Running single threaded: False\"</code> message:</p> python cli.py --single-threadedRunning single theaded: TrueRunning single threaded...python cli.pyRunning single theaded: FalseHow many CPU cores do you want to use?: 16Running with threads: 4"},{"location":"learn/advanced_arguments/#custom-parsers","title":"Custom parsers","text":"<p>If the type you want to parse from the user is too complex, you can define your own parser using <code>config</code> as well:</p> <pre><code>import typing as t\nfrom clypi import Command, arg\n\ndef parse_slack(value: t.Any) -&gt; str:\n    if not value.startswith('#'):\n        raise ValueError(\"Invalid Slack channel. It must start with a '#'.\")\n    return value\n\nclass MyCommand(Command):\n    slack: str = arg(parser=parse_slack)\n</code></pre>"},{"location":"learn/beautiful_uis/","title":"Beautiful UIs","text":""},{"location":"learn/beautiful_uis/#colorful-outputs","title":"Colorful outputs","text":"<p>You can easily print colorful text using clypi's <code>cprint</code> (for \"Colored Print\") function.</p> colors.py<pre><code>from clypi import cprint\n\ncprint(\"Some colorful text\", fg=\"green\", bold=True)\ncprint(\"Some more colorful text\", fg=\"red\", strikethrough=True)\n</code></pre> python colors.py Some colorful text Some more colorful text <p>You can also style individual pieces of text:</p> colors.py<pre><code>import clypi\n\nprint(clypi.style(\"This is blue\", fg=\"blue\"), \"and\", clypi.style(\"this is red\", fg=\"red\"))\n</code></pre> python colors.py This is blue and this is red <p>And also create a reusable styler:</p> colors.py<pre><code>import clypi\n\nwrong = clypi.Styler(fg=\"red\", strikethrough=True)\nprint(\"The old version said\", wrong(\"Pluto was a planet\"))\nprint(\"The old version said\", wrong(\"the Earth was flat\"))\n</code></pre> python colors.py The old version said Pluto was a planet The old version said the Earth was flat"},{"location":"learn/beautiful_uis/#boxed-outputs","title":"Boxed outputs","text":"boxed.py<pre><code>import clypi\n\nprint(clypi.boxed(\"Some boxed text\", width=30, align=\"center\"))\n</code></pre> python boxed.py \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503       Some boxed text      \u2503 \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b"},{"location":"learn/beautiful_uis/#stacks","title":"Stacks","text":"stacks.py<pre><code>import clypi\n\nnames = clypi.boxed([\"Daniel\", \"Pedro\", \"Paul\"], title=\"Names\", width=15)\ncolors = clypi.boxed([\"Blue\", \"Red\", \"Green\"], title=\"Colors\", width=15)\nprint(clypi.stack(names, colors))\n</code></pre> python stacks.py \u250f\u2501 Names \u2501\u2501\u2501\u2501\u2501\u2513  \u250f\u2501 Colors \u2501\u2501\u2501\u2501\u2513 \u2503 Daniel      \u2503  \u2503 Blue        \u2503 \u2503 Pedro       \u2503  \u2503 Red         \u2503 \u2503 Paul        \u2503  \u2503 Green       \u2503 \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b  \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b"},{"location":"learn/beautiful_uis/#separators","title":"Separators","text":"separator.py<pre><code>import clypi\n\nprint(clypi.separator(title=\"Some title\", color=\"red\", width=30))\n</code></pre> python separator.py \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501 Some title \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501"},{"location":"learn/beautiful_uis/#spinners","title":"Spinners","text":"<p>Tip</p> <p>Read the Spinner API docs for more detail into how to use this component.</p> spinner.py<pre><code>import asyncio\nfrom clypi import spinner\n\n@spinner(\"Doing work\")\nasync def do_some_work():\n    await asyncio.sleep(2)\n\nasyncio.run(do_some_work())\n</code></pre> python spinner.py  Doing work <p>You can also use it as a context manager:</p> spinner.py<pre><code>import asyncio\nfrom clypi import Spinner\n\nasync def main():\n    async with Spinner(\"Doing something\", capture=True):\n        await asyncio.sleep(2)\n\nasyncio.run(main())\n</code></pre> python spinner.py  Doing something"},{"location":"learn/configuration/","title":"Configuring clypi","text":"<p>Clypi lets you configure the app globally. This means that all the styling will be easy, uniform across your entire app, and incredibly maintainable.</p> <p>For example, this is how you'd achieve a UI like <code>uv</code>'s CLI:</p> <pre><code>from clypi import ClypiConfig, ClypiFormatter, Styler, Theme, configure\n\ntheme: Theme = Theme(\n    usage=Styler(fg=\"green\", bold=True),\n    usage_command=Styler(fg=\"cyan\", bold=True),\n    usage_args=Styler(fg=\"cyan\"),\n    section_title=Styler(fg=\"green\", bold=True),\n    subcommand=Styler(fg=\"cyan\", bold=True),\n    long_option=Styler(fg=\"cyan\", bold=True),\n    short_option=Styler(fg=\"cyan\", bold=True),\n    positional=Styler(fg=\"cyan\"),\n    placeholder=Styler(fg=\"cyan\"),\n    prompts=Styler(fg=\"green\", bold=True),\n)\n\nconfig = ClypiConfig(\n    theme=theme,\n    help_formatter=ClypiFormatter(\n        boxed=False,\n        show_option_types=False,\n    ),\n)\n\nconfigure(config)\n</code></pre> <p><code>uv run -m examples.uv add -c</code></p> <p></p> <p>Tip</p> <p>Read the Configuration API reference docs for more information into the available options.</p>"},{"location":"learn/getting_started/","title":"Getting Started","text":""},{"location":"learn/getting_started/#your-first-cli","title":"Your first CLI","text":"<p>An extremely simple clypi CLI can be built in a couple of lines:</p> cli.py<pre><code>from clypi import Command\nfrom typing_extensions import override\n\nclass Cli(Command):\n    @override\n    async def run(self):\n        print(f\"Hello, world!\")\n\nif __name__ == '__main__':\n    cmd = Cli.parse()\n    cmd.start()\n</code></pre> python cli.py --helpUsage: cli"},{"location":"learn/getting_started/#adding-positional-arguments","title":"Adding positional arguments","text":"<p>Positional arguments are unnamed arguments provided by the user in a specific order. We only care about the position they are in (hence the name positional).</p> <p>In this example, whatever the first argument to our program is will be passed in as <code>name</code>, and the second argument will be passed as <code>age</code> since they're defined in that order.</p> cli.py<pre><code>from clypi import Command, Positional\nfrom typing_extensions import override\n\nclass Cli(Command):\n    name: Positional[str]\n    age: Positional[int]\n\n    @override\n    async def run(self):\n        print(f\"Hello, {self.name}. You are {self.age}!\")\n\nif __name__ == '__main__':\n    cmd = Cli.parse()\n    cmd.start()\n</code></pre> python cli.py --helpUsage: cli [NAME] [AGE]\u250f\u2501 Arguments \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 [NAME]                                                                       \u2503\u2503 [AGE]                                                                        \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b <p>If we run it:</p> python cli.py Daniel 22Hello, Daniel. You are 22!"},{"location":"learn/getting_started/#adding-options","title":"Adding options","text":"<p>Options are named arguments, and they are usually optional. A user of your CLI must provide the name of the argument and the value(s) to assign to it.</p> cli.py<pre><code>from clypi import Command, Positional\nfrom typing_extensions import override\n\nclass Cli(Command):\n    name: Positional[str]\n    age: int | None = None\n\n    @override\n    async def run(self):\n        print(f\"Hello, {self.name}.\")\n        if self.age is not None:\n            print(f\"You are {self.age}!\")\n\nif __name__ == '__main__':\n    cmd = Cli.parse()\n    cmd.start()\n</code></pre> python cli.py --helpUsage: cli [NAME] [OPTIONS]\u250f\u2501 Arguments \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 [NAME]                                                                       \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\u250f\u2501 Options \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 --age &lt;AGE&gt;                                                                  \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b <p>If we run it with and without the <code>--age</code> flag, we get:</p> python cli.py DanielHello, Daniel.python cli.py Daniel --age 22Hello, Daniel.You are 22!"},{"location":"learn/getting_started/#adding-documentation","title":"Adding documentation","text":"<p>As it stands right now, our CLI is a bit difficult to use. We can add documentation to help our users understand what our CLI is and how to use it.</p> <p>To document the overall command we can use Python docstrings. To document each argument and option we can make user of clypi's <code>arg</code> helper.</p> cli.py<pre><code>from clypi import Command, Positional, arg\nfrom typing_extensions import override\n\nclass Cli(Command):\n    \"\"\"A very simple CLI\"\"\"\n\n    name: Positional[str] = arg(help=\"Your name\")\n    age: int | None = arg(None, help=\"Your age in years\")\n\n    @override\n    async def run(self):\n        print(f\"Hello, {self.name}.\")\n        if self.age is not None:\n            print(f\"You are {self.age}!\")\n\nif __name__ == '__main__':\n    cmd = Cli.parse()\n    cmd.start()\n</code></pre> python cli.py --helpA very simple CLIUsage: cli [NAME] [OPTIONS]\u250f\u2501 Arguments \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 [NAME]  Your name                                                            \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\u250f\u2501 Options \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 --age &lt;AGE&gt;  Your age in years                                               \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b"},{"location":"learn/getting_started/#adding-subcommands","title":"Adding subcommands","text":"<p>Our applications sometimes have multiple usecases. To better group each usecase and avoid having too many options and arguments, we can create subcommands. Subcommands allow the user to select which tool to use inside your CLI.</p> <p>Creating subcommands is very easy. Just create more commands and then define a class-level attribute in your main CLI with the name <code>subcommand</code>:</p> cli.py<pre><code>from clypi import Command, Positional, arg\nfrom typing_extensions import override\n\nclass Greet(Command):\n    \"\"\"Say hi to someone\"\"\"\n    name: Positional[str] = arg(help=\"Your name\")\n\n    @override\n    async def run(self):\n        print(f\"Hello, {self.name}\")\n\nclass Wave(Command):\n    \"\"\"Wave at someone\"\"\"\n    name: Positional[str] = arg(help=\"Your name\")\n\n    @override\n    async def run(self):\n        print(f\"\ud83d\udc4b {self.name}\")\n\nclass Cli(Command):\n    \"\"\"A very simple CLI\"\"\"\n    subcommand: Greet | Wave\n\nif __name__ == '__main__':\n    cmd = Cli.parse()\n    cmd.start()\n</code></pre> python cli.py --helpA very simple CLIUsage: cli COMMAND\u250f\u2501 Subcommands \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 greet  Say hi to someone                                                     \u2503\u2503 wave   Wave at someone                                                       \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251bpython cli.py greet --helpSay hi to someoneUsage: cli greet [NAME]\u250f\u2501 Arguments \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 [NAME]  Your name                                                            \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251bpython cli.py wave Daniel\ud83d\udc4b Daniel"},{"location":"learn/getting_started/#prompting-for-values","title":"Prompting for values","text":"<p>Sometimes we want to make arguments required (by not providing a default) but we don't want to force our users to pass in an argument directly. We might want to ask them in a more user-friendly way. For that, we can set up a prompt in case the user does not manually pass in a value:</p> cli.py<pre><code>from clypi import Command, Positional, arg\nfrom typing_extensions import override\n\nclass Cli(Command):\n    \"\"\"A very simple CLI\"\"\"\n    name: Positional[str] = arg(prompt=\"What's your name?\")\n\n    @override\n    async def run(self):\n        print(f\"Hello, {self.name}!\")\n\nif __name__ == '__main__':\n    cmd = Cli.parse()\n    cmd.start()\n</code></pre> python cli.pyWhat's your name?: DanielHello, Daniel!python cli.py DanielHello, Daniel!"},{"location":"learn/getting_started/#built-in-parsers","title":"Built-in parsers","text":"<p>Clypi comes with built-in parsers for all common Python types. See the built-in types section in the API docs to find all supported types and validations. Most often, using a normal Python type will automatically load the right parser, but if you want more control or extra features you can use these directly:</p> <pre><code>from clypi import Command, arg\nimport clypi.parsers as cp\n\nclass MyCommand(Command):\n    file: Path = arg(\n        parser=cp.Path(exists=True),\n    )\n</code></pre> <p>You can also create your own parser if there's a complex data type we do not support. Refer to the Custom parsers docs.</p>"},{"location":"learn/getting_started/#argument-groups","title":"Argument groups","text":"<p>Sometimes you want to separate your options based on behaviors. For example, you might want to split up environment options from output options. For that, just define a <code>group</code> parameter in the <code>arg</code>s you want to group together:</p> cli.py<pre><code>from typing import Literal\nfrom clypi import Command, arg\n\nclass Cli(Command):\n    \"\"\"A very simple CLI\"\"\"\n\n    # Output configs here\n    format: Literal[\"json\", \"raw\"] = arg(\"raw\", help=\"The output format to use\")\n    verbose: bool = arg(False, help=\"Whether to show verbose output\")\n\n    # Cluster configs here...\n    env: Literal[\"qa\", \"prod\"] = arg(\n        \"qa\",\n        help=\"The environment to run in\",\n        group=\"environment\",\n    )\n    cluster: Literal[\"default\", \"secondary\"] = arg(\n        \"default\",\n        help=\"The cluster to run in\",\n        group=\"environment\",\n    )\n\nif __name__ == '__main__':\n    cmd = Cli.parse()\n    cmd.start()\n</code></pre> <p>You can see they now get displayed in different groups:</p> python cli.py --helpA very simple CLIUsage: cli [OPTIONS]\u250f\u2501 Options \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 --format &lt;FORMAT&gt;  The output format to use {JSON|RAW}                       \u2503\u2503 --verbose          Whether to show verbose output                            \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\u250f\u2501 Environment options \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\u2503 --env &lt;ENV&gt;          The environment to run in {QA|PROD}                     \u2503\u2503 --cluster &lt;CLUSTER&gt;  The cluster to run in {DEFAULT|SECONDARY}               \u2503\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b"},{"location":"learn/install/","title":"Install","text":"<p>You can install clypi with your favorite package manager (<code>pip</code>, <code>uv</code>, <code>pipx,</code> etc.). To get started, simply run:</p> uvpip <p>uv add clypiSuccessfully installed clypi</p> <p>pip install clypiSuccessfully installed clypi</p> <p>By default, clypi only installs two dependencies:</p> <ul> <li><code>python-dateutil</code>: to parse almost any date format in the world</li> <li><code>typing-extensions</code>: to provide better typing backwards compatibility for older Python versions</li> </ul>"}]}